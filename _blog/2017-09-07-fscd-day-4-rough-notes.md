---
layout: blog-post
title: "FSCD day 4 - rough notes"
date: "2017-09-07"
categories: [conference notes]
excerpt: "(Blog posts for Day 1, Day 2, Day 3, Day 4 (half day)) I decided to take electronic notes at ICFP and FSCD (colocated) this year, and following the example of various people who put their conference notes online (which I've found useful), I thought I would attempt the same...."
wordpress_url: https://dorchard.wordpress.com/2017/09/07/fscd-day-4-rough-notes/
---

(Blog posts for [Day 1](https://dorchard.wordpress.com/2017/09/04/icfp-fscd-day-1-rough-conference-notes/), [Day 2](https://dorchard.wordpress.com/2017/09/05/icfp-fscd-day-2-rough-notes/), [Day 3](https://dorchard.wordpress.com/2017/09/06/icfp-fscd-day-3-rough-notes/), [Day 4](https://dorchard.wordpress.com/2017/09/07/fscd-day-4-rough-notes/) (half day)) I decided to take electronic notes at [ICFP](http://icfp17.sigplan.org/program/program-icfp-2017) and [FSCD](http://www.cs.ox.ac.uk/conferences/fscd2017/) (colocated) this year, and following the example of various people who put their conference notes online (which I've found useful), I thought I would attempt the same. However, there is a big caveat: my notes are going to be partial and may be incorrect; my apologies to the speakers for any mistakes. 

  * (FSCD Keynote #3) Type systems for the relational verification of higher order programs, Marco Gaboardi
  * (FSCD) Arrays and References in Resource Aware ML, Benjamin Lichtman, Jan Hoffmann
  * (FSCD) The Complexity of Principal Inhabitation, Andrej Dudenhefner, Jakob Rehof
  * (FSCD) Types as Resources for Classical Natural Deduction, Delia Kesner, Pierre Vial



* * *

(FSCD Keynote #3) Type systems for the relational verification of higher order programs, Marco Gaboardi Relational properties $latex R(X_1, X_2) \Rightarrow S(P(X_1), P(X_2))$. For example, take $latex R$ and $latex S$ to be notions of program equivalence (equivalent inputs produce equivalent outputs). Another relation might be in information-flow security where relations $latex R, S$ mean "these two programs are low-level equivalent" (low-security). Another is differential privacy where $latex R$ means two programs differ in one individual data point and $latex S(Y_!, Y_@) = Pr[Y_1] \leq e^\epsilon Pr[Y_2]$. In relational cost analysis, we want to compute the difference in cost (the relative cost) between the two programs (may depend on the input and the underlying relation), e.g., $latex cost(P)-cost(Q) \leq f(X_1, X_2, R, S)$ (giving an upper bound computed in terms of the inputs and underlying relations). This is useful for guaranteeing compile optimisations (not worse, or definitely better), ruling out side-channel attacks (i.e., the $latex \textsf{cost}(e[v_1/x]) - \textsf{cost}(e[v_2/x]) = 0$, such that different inputs do not yield different costs thus information about the inputs is not leaked). Motivating example 1: find in a list of lists (2D data structure). We want to prove that one implementation of this algorithm is faster than the other (I've omitted the code that Marco showed us, which was expressed via a common higher-order function with two different parameter functions to give the two implementations). Motivating example 2: prove a precise upper bound on the relative cost of insertion sort between two lists (different by $latex n$ in length). [Clarkson, Schneider '08] - formalises the idea of 'hyperproperties'. Properties are sets of traces, hyperproperties are sets of sets of traces. Relation verification is a set of pair of traces (a 2-property). They show how to reduce verification of hyperproperties into the verification of properties. Using these kind of results requires encodings, they do not reflect the relational nature of the property, and they do not reflect the connection of the relational reasoning to the programs syntax (see the talk from ICFP day 2, on A Relational Logic for Higher-order Programs). Lots of previous work (going back to Abadi's System R). Relational typing: $latex \Gamma \vdash t_1 \approx t_2 : \tau$. Talk about relational properties of the input and relational properties of the output. Usually, if we interpret to relations then we want to prove soundness as: $latex (\bar{v_1}, \bar{v_2}) \in [\Gamma] \Rightarrow ([t_1[\bar{v_1}/\Gamma]], t_2[\bar{v_2}/Gamma]]) \in [\tau]$.\ How can we reason about the cost? Two approaches from here: (1) lightweight typing (bottom up) extending type system with the necessary constructors, (2) heavyweight typing (top down) use a powerful type system and encode the needed constructions. (In the future, we want to find a balance between the two approaches). Approach (1) (lightweight) called Relcost a relational refinement type-and-effect system. The idea is to take advantage of structural similarities between programs and inputs as much as possible. There will be two sorts of type (unary and relational). Typing judgments $latex \Omega \vdash^U_L t : A$ where $latex U$ is the upper bound and $latex L$ is the lower bound execution cost, which are thought of as a unary effect. A relational judgement $latex \Gamma \vdash t_1 \ominus t_2 \preceq D : \tau$ where $latex D$ is the upper bound on the relative cost of the two programs. The types have an annotation function type (like in normal effect systems) $latex \sigma \xrightarrow{U, L} \tau$ and data types for integers and lists have indices to express dependencies. e.g. $latex n : \textsf{int}, f : \textsf{int} \xrightarrow{k, k} \textsf{int} \vdash^{k+1}_1 \textsf{if} \, n \leq 0 \textsf{then} f \; n \textsf{else} \; 1 : \textsf{int}$. But if we know that $latex n$ is known to be $latex 5$ this can be refined (with the type $latex n : \textsf{int}[5]$ in the indices, which will change the bound to $\vdash^{k+1}_{k+1}$. The relational types are a little different. There is still a latent effect on function types, but is now a single relative cost $latex \sigma \xrightarrow{D} \tau$. Judgements are like the following, which says equal integers have zero cost: $latex \Gamma \vdash n \ominus n \preceq 0 : \textsf{int}_r$. The unary cost and relational cost are connected as follows: $latex \dfrac{|\Gamma| \vdash^U_{-} t_1 : A \qquad |\Gamma| \vdash^{-}_L t_2 : A}{\Gamma \vdash t_1 \ominus t_2 \preceq U - L : \textsf{U} A}$ Thus, we can drop into the unary cost to compute a worst and best run time individual, and then combine these into a relative cost. There is a box modality which captures terms which have the same cost and allow a reseting therefore of the differential cost, e.g., if we have identical terms then: $latex \dfrac{\Gamma \vdash t \ominus t \preceq D : \tau \qquad \forall x . \Gamma(x) \sqsubseteq \Box \Gamma(x)}{\Gamma \vdash t \ominus t \preceq 0 : \Box \tau}$. The type $latex \textsf{List}^\alpha{I} \tau$ captures lists which differ in less than $latex \alpha$ positions. This interacts with the $latex \Box$ type in order to capture the notion of differing numbers of elements in the list. In the semantics, the relative cost is pushed inside the semantics (some step-indexed logical relations are used, details not shown). Going back to the earlier example of searching nested lists, we see a typing of $latex 1 \leq |\texttt{find1}| \leq 3n$ and $latex 3n \leq |\texttt{find2}| \leq 4n$ meaning $latex \texttt{find1}$ has a relatively smaller cost. Plugging this into the higher-order function and doing the type derivation again gives a looser bound. Approach (2) is the heavyweight approach was presented earlier at ICFP (A Relational Logic for Higher-order Programs), the language RHOL (Relational Higher Order Logic). Has relational and unary judgments, where the relational rule is $latex \Gamma \mid \Psi \vdash t_1 : \tau_1 \approx t_2 : \tau_2 \mid \theta$ which contains term variable assertions $latex \Psi$ and relational assertion $latex \theta$. In the type system, some rules are synchronous (building up the related two terms with the same syntactic construct) or asynchronous (building up one of the terms). HOL terms can be encoded into RHOL, and vice versa (a bit like the hyperproperty result of Clarkson/Schneider), but RHOL is much easier to work with for relational reasoning but also all the power of HOL can be embedded into RHOL. The system $latex R^C$ is a monadic meta language with a specific cost effect (with $latex \textsf{cstep}_n(m)$ introducing a cost. Intuition: if a term $latex m$ is closed and $m \Downarrow_n v$ then $m \cong \textsf{cstep}_n(v)$.We can define formulae in HOL which all us to reason about these explicit cost terms and their quantities: we can define what we need in the logic. For computing a relative upper bound on the insertion sort, we want to prove $latex \textsf{UnsortedDiff}(l_1, l_2, n) \Rightarrow \textsf{cost}(\textit{isort} \, l_1) - \textsf{cost}(\textit{isort} \, l_2) \leq n$. Using the system , we can prove this property, using a suitable invariant/predicate over the input and output list(s). Take home: type-based relational verification is a large research space that needs more work. Q: what about recursion? In the first system, letrec is included straightforwardly, in the second system the assumption is terminating (general) recursion. Q: are the costs tied to a specific evaluation strategy? Yes, but one can encode different ones in the system. (Both systems are parametric in the way you count cost). In the first system, this is part of the typing, in the second, this comes where you put monadic cost operations $latex \textsf{cstep}$. 

* * *

(FSCD) **Arrays and References in Resource Aware ML** , Benjamin Lichtman, Jan Hoffmann Resource-aware ML (RAML) - model resource usages of programs with cost semantics, e.g., implement Quicksort and it produce the bound $latex 14n^2 + 19^n + c$ (I forgot what the constant c was). This work introduces references and arrays to enable analysis of programs where resource consumption depends on the data stored in mutable structures (references and arrays). How does it work? Automatic amortized resource analysis. Assign "potential" functions to a data structures, which will pay the resource consumption cost, then hopefully there is some left over for later. This propagates backwards to give the overall upper bound cost. Each variable in scope may contribute (carry) potential, e.g., recursive data types (such as $latex x : \textsf{list}^2(\textsf{int})$ that is it can contribute $latex 2n$ units of potential where $latex n$ is the length of the list. Based on an affine type system (all variable used at most once). Subexpressions are bound to variables whenever possible (share-let normal form) in order to explicitly track when things are evaluated (via variables). When a variable carrying potential needs to be shared, the potential can be explicitly split `share x as (x1, x2) in e` in order to use a variable more than once (gives you contraction). This splits the potential of $latex x$ across the two variables. Benjamin walked us through a nice example with appending to a list. Now let's add references. 
    
    
    g l = 
      let t = ref l in 
      share r as (r1, r2) in  -- r2 : L^1 (int)
      let _ = h r1 in   -- h : (L^q int) ref -> int  
                        -- (need to make the type of this stronger)
      append (!r2, []) -- append : L^1(int) * L^0(int) -> L^0(int)

One approach is to carry around extra information about possible effects, but they want to keep effects out of the type system because they seem them as cumbersome and difficult to use. Instead, strengthen contracts by require that potential annotations of data inside references are fixed. 
    
    
    g l = 
      let t = ref l in 
      share r as (r1, r2) in  -- the restricted h means r1 and r2 have 
                              -- to have the same type
      let _ = h r1 in   -- h : (L^1 int) ref -> int  
      append (!r2, [])

Introduce a `swap` command as the only way to update a cell, that behaves like: 
    
    
    swap (r, l) = let x = !r in (let _ = r := l in x)

Requires that data placed into a cell has the same type as data being taken out, ensures that potential annotations of mutable cells never change (the only way to update a cell). Thus, swap is the well-typed version of dereference in situations where you need to work with potential. Thus, require the previous program to use swap on `r2` with an empty list instead of a direct dereference in the last line. The paper has a detailed example of depth-first search (stateful) which shows more of the details related to how to work with state and potentials. This also utilises an idea of "wrapper" types. Introduce a notion of "memory typing", which tracks all memory locations pointed to by mutual references, this is require to prove the soundness of the cost analysis (based on the free potential of the system, the potential of the context, and the potential of each mutable memory reference). Mutable arrays were then a natural extension from this basis, with an array-swap operation for updating an array cell. In the future, they'd like to create some syntactic sugar so that the programming style is not affected as much by having to instead swap, aswap, and wrapper types. Would like to investigate how fixed potential annotations restrict the inhabitants of a type (Yes, yes, this is very interesting!) I asked about what happens if you write down Landin's Knot to get recursion via higher-order state: Benjamin answered that functions don't get given potential so storing and updating functions in a reference would type correctly. I still wonder if this would let me get the correct potential bounds for a recursive algorithm (like DFS) if the recursion was implemented via higher-order state. 

* * *

(FSCD) **The Complexity of Principal Inhabitation** , Andrej Dudenhefner, Jakob Rehof In the simply-typed lambda calculus (STLC), with principle types. We say $latex \tau$ is the principle type of $latex M$ if $latex \vdash M : \tau$ and for all types $latex \sigma$ such that $latex M : \sigma$ there exists a substitution $latex S$ such that $latex S(\tau) = \sigma$. Definition: (Normal Principal Inhabitant), We say that a term M in beta-normal form is a normal principal inhabitant of a type t, if t is the principal type of M. This work shows that principal inhabitation for STLC is PSPACE-complete (in 1979 it was shown that inhabitation (not considering) principality is PSPACE-complete). Thus, this work seeks to answer the following: since principality is a global property of derivations, does it increase the complexity of inhabitation? This is also practically interesting for type-based program synthesis, since a normal principal inhabitant of a type is a natural implementation of the type. For example, $latex a \rightarrow a \rightarrow a$ is inhabited by the K combinator $latex K = \lambda x . \lambda y . x$ but is not principally inhabited (I haven't understood why yet). The proof is based on the subformula calculus. The subformula calculus provides paths to index types (as trees) which are strings of either 1 or 2. This is useful for reasonable about subformulae, where the usual STLC rules are re-expressed in terms of type paths, e.g., $latex \dfrac{\Gamma, x : 1\pi \vdash e : 2\pi}{\Gamma \vdash \lambda x . e : \pi}$. Define relations on paths, $latex R_M$ as the minimal equivalence relation for a beta-normal term $latex M$ (capture constraints on subformulae of terms) and $latex R_\tau$ which defines an equivalence relation on paths of paths with common subpaths (capture constraints on subformulae on types). (I had to step out, so missed the end). 

* * *

(FSCD) **Types as Resources for Classical Natural Deduction** , Delia Kesner, Pierre Vial Quantitative types seen as resources (can't be duplicated); they provide simple arithmetical arguments to prove operational equivalences. These ideas are extended to classical logic in this talk. In simple types, typability implies normalisation. With intersection types this is an equivalence, i.e., normalising also implies typability. In an intersection type system, a variable can be assigned several types, e.g. $latex x : A \wedge B \wedge C \wedge B$ (note the two occurrences of $latex B$) where intersection is associative, commutative and (possibly) idempotent. In 1994, Gardner introduces a system which is not idempotent, where types are now multisets (rather than sets in the earlier formulations). This has the flavour of linear logic resources (my interpretation: the types can then capture how many times a variable is used (quantitative) if we contraction takes the intersection of the two types and intersection is non-idempotent, e.g., $latex x_1 : A \wedge B, x_2 : B \wedge C \leadsto x : A \wedge B \wedge B \wedge C$). In the literature, we see how to build a computational interpretation of classical natural deduction: Intuitionistic Logic + Peirce's law gives classical logic and Felleisen's call-cc operator gives the computational interpretation. Relatedly, the lambda_mu calculus (Parigot 92) give a direct interpretation of classical natural deduction. Types are strict where intersection can only appear on the left-hand side of a function arrow. Interestingly, you can have a situation where the type of a lambda abstraction has an empty intersection of types in its source type. In order to get normalisation in this context, the system was extended a bit to deal with this (I didn't capture this part, see paper). The full system had rules to ensure this didn't happen. A notion of "weighted" subject reduction is defined, where the size of a derivation tree is strictly decreasing during reduction.
